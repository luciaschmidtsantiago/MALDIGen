
"""
t-SNE visualization script for MALDIVAS spectra

This script loads real spectra (train/val/test/ood) and synthetic spectra
generated by various models, normalizes them, computes a global t-SNE
embedding, and produces comparison plots (train vs generated, train vs test,
train vs OOD). The script is written to be robust to different saved array
formats (numpy .npy, pickled objects, or torch saved tensors).

Typical usage:
        - Run `compute_tsne(model_names)` with `compute=True` to recompute and
            save the t-SNE arrays under `results/tsne/`.
        - By default the script loads precomputed .npy t-SNE arrays and
            generates plots for each model listed in `model_names`.

The code is careful to normalize spectra per-sample and globally before
computing t-SNE, and uses a helper `safe_load_array` to handle multiple
file serialization formats.
"""

import os
import sys
import numpy as np
import torch
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from dataloader.data import load_data
from utils.plotting_utils import LABEL_TO_HEX, printed_names
from utils.visualization import safe_load_array

def compute_tsne(model_names):
    # Device used when loading PyTorch objects
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # Paths to pickles for real datasets and synthetic results root
    pickle_marisma = "pickles/MARISMa_study.pkl"
    pickle_driams = "pickles/DRIAMS_study.pkl"
    generated_root = "results/generated_spectra"

    # Load real datasets (train/val/test/ood) and their labels
    print("Loading real datasets...")
    train, val, test, ood = load_data(pickle_marisma, pickle_driams, logger=None, get_labels=True)
    # mapping from numeric id to readable species name
    label_convergence = train.label_convergence
    splits = {
        "train": (train.data, train.labels),
        "val": (val.data, val.labels),
        "test": (test.data, test.labels),
        "ood": (ood.data, ood.labels),
    }

    # Accumulators for all samples, labels and their source (train/val/test/ood or model_labelX)
    X_all, y_all, src_all = [], [], []

    # Normalize each real spectrum independently to [0, 1] before concatenation
    for split, (X, y) in splits.items():
        if isinstance(X, torch.Tensor):
            X = X.cpu().numpy()
        if isinstance(y, torch.Tensor):
            y = y.cpu().numpy()
        # per-sample min-max scaling (axis=1) to preserve shape/relative peaks
        X_norm = (X - X.min(axis=1, keepdims=True)) / (X.max(axis=1, keepdims=True) - X.min(axis=1, keepdims=True) + 1e-8)
        X_all.append(X_norm)
        y_all.append(y)
        src_all += [split] * len(X)

    # Diagnostic: save a quick plot of a few training spectra (normalized)
    plt.figure(figsize=(12, 6))
    for i in range(5):
        plt.plot(X_all[0][i], label=f"Train {i}")
    plt.title("First 5 Training Spectra (Normalized)")
    plt.xlabel("Feature Index")
    plt.ylabel("Intensity")
    plt.legend()
    plt.tight_layout()
    save_dir = os.path.join("results", "tsne", "pruebas")
    os.makedirs(save_dir, exist_ok=True)
    plt.savefig(os.path.join(save_dir, "first_5_training_spectra.png"), dpi=300)
    plt.show()

    # Show first 5 generated spectra for the first model that has saved files
    for model_name in model_names:
        model_dir = os.path.join(generated_root, model_name)
        if not os.path.exists(model_dir):
            continue
        label_files = sorted([f for f in os.listdir(model_dir) if f.endswith(".npy")])
        if label_files:
            arr = safe_load_array(os.path.join(model_dir, label_files[0]), device=device)
            if isinstance(arr, np.ndarray) and arr.ndim == 3:
                arr = arr.squeeze(1)
            # per-sample normalize before plotting
            arr_norm = (arr - arr.min(axis=1, keepdims=True)) / (arr.max(axis=1, keepdims=True) - arr.min(axis=1, keepdims=True) + 1e-8)
            plt.figure(figsize=(12, 6))
            for i in range(min(5, arr_norm.shape[0])):
                plt.plot(arr_norm[i], label=f"{model_name} Gen {i}")
            plt.title(f"First 5 Generated Spectra ({model_name}, Normalized)")
            plt.xlabel("Feature Index")
            plt.ylabel("Intensity")
            plt.legend()
            plt.tight_layout()
            save_dir = os.path.join("results", "tsne", "pruebas")
            os.makedirs(save_dir, exist_ok=True)
            plt.savefig(os.path.join(save_dir, f"first_5_generated_spectra_{model_name}.png"), dpi=300)
            plt.show()
            break

    # Load synthetic spectra for each model and label file found
    for model_name in model_names:
        model_dir = os.path.join(generated_root, model_name)
        if not os.path.exists(model_dir):
            print(f"Skipping missing model folder: {model_dir}")
            continue
        label_files = sorted([f for f in os.listdir(model_dir) if f.endswith(".npy")])
        for f in label_files:
            path = os.path.join(model_dir, f)
            # assume filenames like "<label>_... .npy" where label is numeric
            label_id = int(f.split("_")[0])
            arr = safe_load_array(path, device=device)
            # squeeze channel dimension if present (N,1,L) -> (N,L)
            if isinstance(arr, np.ndarray) and arr.ndim == 3:
                arr = arr.squeeze(1)
            elif isinstance(arr, np.ndarray) and arr.dtype == object:
                arr = np.vstack(arr)
            # Normalize each generated spectrum independently
            arr_norm = (arr - arr.min(axis=1, keepdims=True)) / (arr.max(axis=1, keepdims=True) - arr.min(axis=1, keepdims=True) + 1e-8)
            X_all.append(arr_norm)
            y_all.append(np.full(arr.shape[0], label_id))
            src_all += [f"{model_name}_label{label_id}"] * arr.shape[0]
            print(f"Loaded {f} ({arr.shape}, dtype={arr.dtype})")

    # Concatenate all accumulated arrays into single big arrays for t-SNE
    X_all = np.vstack(X_all)
    y_all = np.concatenate(y_all)
    src_all = np.array(src_all)

    print(f"Total samples: {len(X_all)}, feature dim: {X_all.shape[1]}")

    # Global normalization (bring everything to same overall scale)
    X_all = (X_all - X_all.min()) / (X_all.max() - X_all.min() + 1e-8)

    # Compute 2D t-SNE embedding
    print("Running t-SNE...")
    tsne = TSNE(n_components=2, perplexity=60, learning_rate='auto', init='pca', random_state=42)
    X_embedded = tsne.fit_transform(X_all)

    # Map numeric label â†’ human-readable label using train.label_convergence
    label_names = np.array([
        label_convergence.get(str(int(lbl)), str(int(lbl))) for lbl in y_all
    ])

    return X_embedded, y_all, label_names, src_all

def plot_tsne(X_tsne, label_names, mask1, mask2, tsne_dir, label_mask1='Train', label_mask2='Test'):
    """
    Plot t-SNE comparison between two masks (e.g., train vs test) colored by label.
    Parameters:
        X_tsne: np.ndarray of shape (N, 2), t-SNE embeddings
        label_names: np.ndarray of shape (N,), human-readable labels for each sample
        mask1: boolean np.ndarray of shape (N,), mask for first group (e.g., train)
        mask2: boolean np.ndarray of shape (N,), mask for second group (e.g., test)
        tsne_dir: str, directory to save the plot
        label_mask1: str, label for first group in legend
        label_mask2: str, label for second group in legend
    """

    idx_to_name = {str(i): LABEL_NAMES[i] for i in range(len(LABEL_NAMES))}

    # Samples mask1 (typically train)
    X_mask1 = X_tsne[mask1]
    labels_mask1 = np.array([str(l).strip() for l in label_names[mask1]])
    labels_mask1_named = np.array([idx_to_name.get(l, l) for l in labels_mask1])

    # Samples mask2 (typically generated/test/ood)
    X_mask2 = X_tsne[mask2]
    labels_mask2 = np.array([str(l).strip() for l in label_names[mask2]])
    labels_mask2_named = np.array([idx_to_name.get(l, l) for l in labels_mask2])

    # Plot t_SNE of train VS mask by label
    plt.figure(figsize=(14, 7))
    for lbl in LABEL_NAMES:
        lbl_str = str(lbl)
        pretty = printed_names.get(lbl_str, lbl_str)
        pretty_italic = f"$\\it{{{pretty}}}$"
        mask1_idx = np.where(labels_mask1_named == lbl)[0]
        if len(mask1_idx) > 0:
            plt.scatter(
                X_mask1[mask1_idx, 0], X_mask1[mask1_idx, 1],
                color=LABEL_TO_HEX.get(lbl, '#888888'), marker='o', alpha=0.6,
                label=f"{label_mask1}: {pretty_italic}", s=30, edgecolor='k', linewidth=0.5
            )
        mask2_idx = np.where(labels_mask2_named == lbl)[0]
        if len(mask2_idx) > 0:
            plt.scatter(
                X_mask2[mask2_idx, 0], X_mask2[mask2_idx, 1],
                color=LABEL_TO_HEX.get(lbl, '#888888'), marker='^', alpha=0.8,
                label=f"{label_mask2}: {pretty_italic}", s=40
            )
    plt.xlabel("t-SNE 1")
    plt.ylabel("t-SNE 2")
    plt.title(f"t-SNE: {label_mask1} (circles) vs {label_mask2} (triangles) by Label")
    handles, labels_plt = plt.gca().get_legend_handles_labels()
    # Deduplicate legend entries while preserving mathtext formatting
    legend_items = []
    seen = set()
    for h, l in zip(handles, labels_plt):
        if l not in seen:
            legend_items.append((h, l))
            seen.add(l)
    handles_dedup, labels_dedup = zip(*legend_items)
    plt.legend(handles_dedup, labels_dedup, fontsize='small', loc='center left', bbox_to_anchor=(1.02, 0.5), borderaxespad=0)
    plt.tight_layout(rect=[0, 0, 0.75, 1])
    # Save plot
    plot_name = f"tsne_{label_mask1.lower()}_vs_{label_mask2.lower()}_by_label.png"
    plt.savefig(os.path.join(tsne_dir, plot_name), dpi=300, bbox_inches='tight')
    plt.close()
    print(f"Saved plot to {os.path.join(tsne_dir, plot_name)}")


if __name__ == "__main__":

    model_names = [
        "cvae_MLP3_32",
        "cvae_CNN3_8_MxP",
        "cgan_MLP3_32_weighted",
        "cgan_CNN3_32_weighted",
        "dm_S",
        "dm_M",
        "dm_L",
        "dm_XL",
        "dm_deep",
    ]

    # Paths
    tsne_dir = "results/tsne"
    X_tsne_path = os.path.join(tsne_dir, "X_tsne.npy")
    labels_path = os.path.join(tsne_dir, "labels.npy")
    label_names_path = os.path.join(tsne_dir, "label_names.npy")
    sources_path = os.path.join(tsne_dir, "sources.npy")

    # Compute t-SNE embeddings and save arrays
    compute = False
    if compute:
        X_embedded, y_all, label_names_arr, src_all = compute_tsne(model_names)

        # Save
        os.makedirs(tsne_dir, exist_ok=True)
        np.save(X_tsne_path, X_embedded.astype(np.float32))
        np.save(labels_path, y_all.astype(np.int16))
        np.save(label_names_path, label_names_arr)
        np.save(sources_path, src_all)
        print(f"Saved t-SNE arrays to {tsne_dir}/")

    # Load arrays for plotting
    X_tsne = np.load(X_tsne_path)
    labels = np.load(labels_path)
    label_names = np.load(label_names_path, allow_pickle=True)
    sources = np.load(sources_path, allow_pickle=True)
    
    # Hex colors from Spectral colormap
    LABEL_NAMES = list(LABEL_TO_HEX.keys())

    # Get train mask
    train_mask = sources == "train"

    # Plot t-SNE of train vs generated samples by label for each model
    for model_name in model_names:
        # Select generated samples for this model and plot vs train
        generated_prefix = f"{model_name}_label"
        gen_mask = np.char.startswith(sources.astype(str), generated_prefix)
        plot_tsne(X_tsne, label_names, train_mask, gen_mask, tsne_dir, label_mask1='Train', label_mask2=f'{model_name}')

    # Plot t-SNE of train vs test samples by label for each model
    test_mask = sources == "test"
    plot_tsne(X_tsne, label_names, train_mask, test_mask, tsne_dir, label_mask1='Train', label_mask2='Test')
    
    # Plot t-SNE of train vs OOD samples by label for each model
    ood_mask = sources == "ood"
    plot_tsne(X_tsne, label_names, train_mask, ood_mask, tsne_dir, label_mask1='Train', label_mask2='OOD')